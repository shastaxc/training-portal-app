{"remainingRequest":"C:\\Projects\\training-portal-app\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\Projects\\training-portal-app\\node_modules\\@angular\\flex-layout\\esm5\\extended.es5.js","dependencies":[{"path":"C:\\Projects\\training-portal-app\\node_modules\\@angular\\flex-layout\\esm5\\extended.es5.js","mtime":499162500000},{"path":"C:\\Projects\\training-portal-app\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1532030343113},{"path":"C:\\Projects\\training-portal-app\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** PURE_IMPORTS_START tslib,_angular_core,_angular_common,_angular_flex_layout_core,_angular_flex_layout_flex,_angular_platform_browser PURE_IMPORTS_END */\nimport { __extends } from 'tslib';\nimport { Directive, ElementRef, Input, Inject, Optional, PLATFORM_ID, IterableDiffers, KeyValueDiffers, Renderer2, Self, SecurityContext, NgModule } from '@angular/core';\nimport { isPlatformServer, NgClass, NgStyle } from '@angular/common';\nimport { BaseDirective, MediaMonitor, SERVER_TOKEN, StyleUtils, BaseDirectiveAdapter, CoreModule } from '@angular/flex-layout/core';\nimport { LayoutDirective } from '@angular/flex-layout/flex';\nimport { DomSanitizer } from '@angular/platform-browser';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * This directive provides a responsive API for the HTML <img> 'src' attribute\n * and will update the img.src property upon each responsive activation.\n *\n * e.g.\n *      <img src=\"defaultScene.jpg\" src.xs=\"mobileScene.jpg\"></img>\n *\n * @see https://css-tricks.com/responsive-images-youre-just-changing-resolutions-use-src/\n */\nvar ImgSrcDirective = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(ImgSrcDirective, _super);\n    /* tslint:enable */\n    function ImgSrcDirective(_elRef, _monitor, _styler, _platformId, _serverModuleLoaded) {\n        var _this = _super.call(this, _monitor, _elRef, _styler) || this;\n        _this._elRef = _elRef;\n        _this._monitor = _monitor;\n        _this._styler = _styler;\n        _this._platformId = _platformId;\n        _this._serverModuleLoaded = _serverModuleLoaded;\n        _this._cacheInput('src', _elRef.nativeElement.getAttribute('src') || '');\n        if (isPlatformServer(_this._platformId) && _this._serverModuleLoaded) {\n            _this.nativeElement.setAttribute('src', '');\n        }\n        return _this;\n    }\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcBase\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this.cacheDefaultSrc(val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcXs\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('srcXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcSm\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('srcSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcMd\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('srcMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcLg\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('srcLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcXl\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('srcXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcLtSm\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('srcLtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcLtMd\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('srcLtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcLtLg\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('srcLtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcLtXl\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('srcLtXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcGtXs\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('srcGtXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcGtSm\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('srcGtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcGtMd\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('srcGtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"srcGtLg\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('srcGtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Listen for responsive changes to update the img.src attribute\n     */\n    /**\n     * Listen for responsive changes to update the img.src attribute\n     * @return {?}\n     */\n    ImgSrcDirective.prototype.ngOnInit = /**\n     * Listen for responsive changes to update the img.src attribute\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            _super.prototype.ngOnInit.call(this);\n            if (this.hasResponsiveKeys) {\n                // Listen for responsive changes\n                this._listenForMediaQueryChanges('src', this.defaultSrc, function () {\n                    _this._updateSrcFor();\n                });\n            }\n            this._updateSrcFor();\n        };\n    /**\n     * Update the 'src' property of the host <img> element\n     */\n    /**\n     * Update the 'src' property of the host <img> element\n     * @return {?}\n     */\n    ImgSrcDirective.prototype.ngOnChanges = /**\n     * Update the 'src' property of the host <img> element\n     * @return {?}\n     */\n        function () {\n            if (this.hasInitialized) {\n                this._updateSrcFor();\n            }\n        };\n    /**\n     * Use the [responsively] activated input value to update\n     * the host img src attribute or assign a default `img.src=''`\n     * if the src has not been defined.\n     *\n     * Do nothing to standard `<img src=\"\">` usages, only when responsive\n     * keys are present do we actually call `setAttribute()`\n     */\n    /**\n     * Use the [responsively] activated input value to update\n     * the host img src attribute or assign a default `img.src=''`\n     * if the src has not been defined.\n     *\n     * Do nothing to standard `<img src=\"\">` usages, only when responsive\n     * keys are present do we actually call `setAttribute()`\n     * @return {?}\n     */\n    ImgSrcDirective.prototype._updateSrcFor = /**\n     * Use the [responsively] activated input value to update\n     * the host img src attribute or assign a default `img.src=''`\n     * if the src has not been defined.\n     *\n     * Do nothing to standard `<img src=\"\">` usages, only when responsive\n     * keys are present do we actually call `setAttribute()`\n     * @return {?}\n     */\n        function () {\n            if (this.hasResponsiveKeys) {\n                var /** @type {?} */ url = this.activatedValue || this.defaultSrc;\n                if (isPlatformServer(this._platformId) && this._serverModuleLoaded) {\n                    this._styler.applyStyleToElement(this.nativeElement, { 'content': url ? \"url(\" + url + \")\" : '' });\n                }\n                else {\n                    this.nativeElement.setAttribute('src', String(url));\n                }\n            }\n        };\n    /**\n     * Cache initial value of 'src', this will be used as fallback when breakpoint\n     * activations change.\n     * NOTE: The default 'src' property is not bound using @Input(), so perform\n     * a post-ngOnInit() lookup of the default src value (if any).\n     */\n    /**\n     * Cache initial value of 'src', this will be used as fallback when breakpoint\n     * activations change.\n     * NOTE: The default 'src' property is not bound using \\@Input(), so perform\n     * a post-ngOnInit() lookup of the default src value (if any).\n     * @param {?=} value\n     * @return {?}\n     */\n    ImgSrcDirective.prototype.cacheDefaultSrc = /**\n     * Cache initial value of 'src', this will be used as fallback when breakpoint\n     * activations change.\n     * NOTE: The default 'src' property is not bound using \\@Input(), so perform\n     * a post-ngOnInit() lookup of the default src value (if any).\n     * @param {?=} value\n     * @return {?}\n     */\n        function (value) {\n            this._cacheInput('src', value || '');\n        };\n    Object.defineProperty(ImgSrcDirective.prototype, \"defaultSrc\", {\n        /**\n         * Empty values are maintained, undefined values are exposed as ''\n         */\n        get: /**\n         * Empty values are maintained, undefined values are exposed as ''\n         * @return {?}\n         */ function () {\n            return this._queryInput('src') || '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ImgSrcDirective.prototype, \"hasResponsiveKeys\", {\n        /**\n         * Does the <img> have 1 or more src.<xxx> responsive inputs\n         * defined... these will be mapped to activated breakpoints.\n         */\n        get: /**\n         * Does the <img> have 1 or more src.<xxx> responsive inputs\n         * defined... these will be mapped to activated breakpoints.\n         * @return {?}\n         */ function () {\n            return Object.keys(this._inputMap).length > 1;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return ImgSrcDirective;\n}(BaseDirective));\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Directive to add responsive support for ngClass.\n * This maintains the core functionality of 'ngClass' and adds responsive API\n * Note: this class is a no-op when rendered on the server\n */\nvar ClassDirective = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(ClassDirective, _super);\n    /* tslint:enable */\n    function ClassDirective(monitor, _iterableDiffers, _keyValueDiffers, _ngEl, _renderer, _ngClassInstance, _styler) {\n        var _this = _super.call(this, monitor, _ngEl, _styler) || this;\n        _this.monitor = monitor;\n        _this._iterableDiffers = _iterableDiffers;\n        _this._keyValueDiffers = _keyValueDiffers;\n        _this._ngEl = _ngEl;\n        _this._renderer = _renderer;\n        _this._ngClassInstance = _ngClassInstance;\n        _this._styler = _styler;\n        _this._configureAdapters();\n        return _this;\n    }\n    Object.defineProperty(ClassDirective.prototype, \"ngClassBase\", {\n        set: /**\n         * Intercept ngClass assignments so we cache the default classes\n         * which are merged with activated styles or used as fallbacks.\n         * Note: Base ngClass values are applied during ngDoCheck()\n         * @param {?} val\n         * @return {?}\n         */ function (val) {\n            var /** @type {?} */ key = 'ngClass';\n            this._base.cacheInput(key, val, true);\n            this._ngClassInstance.ngClass = this._base.queryInput(key);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"klazz\", {\n        set: /**\n         * Capture class assignments so we cache the default classes\n         * which are merged with activated styles and used as fallbacks.\n         * @param {?} val\n         * @return {?}\n         */ function (val) {\n            var /** @type {?} */ key = 'class';\n            this._base.cacheInput(key, val);\n            this._ngClassInstance.klass = val;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassXs\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngClassXs', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassSm\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngClassSm', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassMd\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngClassMd', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassLg\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngClassLg', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassXl\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngClassXl', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassLtSm\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngClassLtSm', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassLtMd\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngClassLtMd', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassLtLg\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngClassLtLg', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassLtXl\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngClassLtXl', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassGtXs\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngClassGtXs', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassGtSm\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngClassGtSm', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassGtMd\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngClassGtMd', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ClassDirective.prototype, \"ngClassGtLg\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngClassGtLg', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    // ******************************************************************\n    // Lifecycle Hooks\n    // ******************************************************************\n    /**\n     * For @Input changes on the current mq activation property\n     */\n    /**\n     * For \\@Input changes on the current mq activation property\n     * @param {?} changes\n     * @return {?}\n     */\n    ClassDirective.prototype.ngOnChanges = /**\n     * For \\@Input changes on the current mq activation property\n     * @param {?} changes\n     * @return {?}\n     */\n        function (changes) {\n            if (this._base.activeKey in changes) {\n                this._ngClassInstance.ngClass = this._base.mqActivation.activatedInput || '';\n            }\n        };\n    /**\n     * @return {?}\n     */\n    ClassDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            this._configureMQListener();\n        };\n    /**\n     * For ChangeDetectionStrategy.onPush and ngOnChanges() updates\n     */\n    /**\n     * For ChangeDetectionStrategy.onPush and ngOnChanges() updates\n     * @return {?}\n     */\n    ClassDirective.prototype.ngDoCheck = /**\n     * For ChangeDetectionStrategy.onPush and ngOnChanges() updates\n     * @return {?}\n     */\n        function () {\n            this._ngClassInstance.ngDoCheck();\n        };\n    /**\n     * @return {?}\n     */\n    ClassDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._base.ngOnDestroy();\n            delete this._ngClassInstance;\n        };\n    // ******************************************************************\n    // Internal Methods\n    // ******************************************************************\n    /**\n     * Configure adapters (that delegate to an internal ngClass instance) if responsive\n     * keys have been defined.\n     */\n    /**\n     * Configure adapters (that delegate to an internal ngClass instance) if responsive\n     * keys have been defined.\n     * @return {?}\n     */\n    ClassDirective.prototype._configureAdapters = /**\n     * Configure adapters (that delegate to an internal ngClass instance) if responsive\n     * keys have been defined.\n     * @return {?}\n     */\n        function () {\n            this._base = new BaseDirectiveAdapter('ngClass', this.monitor, this._ngEl, this._styler);\n            if (!this._ngClassInstance) {\n                // Create an instance NgClass Directive instance only if `ngClass=\"\"` has NOT been defined on\n                // the same host element; since the responsive variations may be defined...\n                this._ngClassInstance = new NgClass(this._iterableDiffers, this._keyValueDiffers, this._ngEl, this._renderer);\n            }\n        };\n    /**\n     * Build an mqActivation object that bridges mql change events to onMediaQueryChange handlers\n     * NOTE: We delegate subsequent activity to the NgClass logic\n     *       Identify the activated input value and update the ngClass iterables...\n     *       Use ngDoCheck() to actually apply the values to the element\n     */\n    /**\n     * Build an mqActivation object that bridges mql change events to onMediaQueryChange handlers\n     * NOTE: We delegate subsequent activity to the NgClass logic\n     *       Identify the activated input value and update the ngClass iterables...\n     *       Use ngDoCheck() to actually apply the values to the element\n     * @param {?=} baseKey\n     * @return {?}\n     */\n    ClassDirective.prototype._configureMQListener = /**\n     * Build an mqActivation object that bridges mql change events to onMediaQueryChange handlers\n     * NOTE: We delegate subsequent activity to the NgClass logic\n     *       Identify the activated input value and update the ngClass iterables...\n     *       Use ngDoCheck() to actually apply the values to the element\n     * @param {?=} baseKey\n     * @return {?}\n     */\n        function (baseKey) {\n            var _this = this;\n            if (baseKey === void 0) {\n                baseKey = 'ngClass';\n            }\n            var /** @type {?} */ fallbackValue = this._base.queryInput(baseKey);\n            this._base.listenForMediaQueryChanges(baseKey, fallbackValue, function (changes) {\n                _this._ngClassInstance.ngClass = changes.value || '';\n                _this._ngClassInstance.ngDoCheck();\n            });\n        };\n    return ClassDirective;\n}(BaseDirective));\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ FALSY = ['false', false, 0];\n/**\n * For fxHide selectors, we invert the 'value'\n * and assign to the equivalent fxShow selector cache\n *  - When 'hide' === '' === true, do NOT show the element\n *  - When 'hide' === false or 0... we WILL show the element\n * @param {?} hide\n * @return {?}\n */\nfunction negativeOf(hide) {\n    return (hide === '') ? false :\n        ((hide === 'false') || (hide === 0)) ? true : !hide;\n}\n/**\n * 'show' Layout API directive\n *\n */\nvar ShowHideDirective = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(ShowHideDirective, _super);\n    /* tslint:enable */\n    /**\n     *\n     */\n    function ShowHideDirective(monitor, layout, elRef, styleUtils, platformId, serverModuleLoaded) {\n        var _this = _super.call(this, monitor, elRef, styleUtils) || this;\n        _this.layout = layout;\n        _this.elRef = elRef;\n        _this.styleUtils = styleUtils;\n        _this.platformId = platformId;\n        _this.serverModuleLoaded = serverModuleLoaded;\n        if (layout) {\n            /**\n                   * The Layout can set the display:flex (and incorrectly affect the Hide/Show directives.\n                   * Whenever Layout [on the same element] resets its CSS, then update the Hide/Show CSS\n                   */\n            /**\n             * The Layout can set the display:flex (and incorrectly affect the Hide/Show directives.\n             * Whenever Layout [on the same element] resets its CSS, then update the Hide/Show CSS\n             */\n            _this._layoutWatcher = layout.layout$.subscribe(function () { return _this._updateWithValue(); });\n        }\n        return _this;\n    }\n    Object.defineProperty(ShowHideDirective.prototype, \"show\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('show', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showXs\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showSm\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showMd\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showLg\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showXl\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showLtSm\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showLtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showLtMd\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showLtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showLtLg\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showLtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showLtXl\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showLtXl', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showGtXs\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showGtXs', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showGtSm\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showGtSm', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showGtMd\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showGtMd', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"showGtLg\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showGtLg', val); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hide\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('show', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideXs\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showXs', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideSm\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showSm', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideMd\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showMd', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideLg\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showLg', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideXl\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showXl', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideLtSm\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showLtSm', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideLtMd\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showLtMd', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideLtLg\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showLtLg', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideLtXl\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showLtXl', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideGtXs\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showGtXs', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideGtSm\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showGtSm', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideGtMd\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showGtMd', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShowHideDirective.prototype, \"hideGtLg\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._cacheInput('showGtLg', negativeOf(val)); },\n        enumerable: true,\n        configurable: true\n    });\n    // *********************************************\n    // Lifecycle Methods\n    // *********************************************\n    /**\n     * Override accessor to the current HTMLElement's `display` style\n     * Note: Show/Hide will not change the display to 'flex' but will set it to 'block'\n     * unless it was already explicitly specified inline or in a CSS stylesheet.\n     */\n    /**\n     * Override accessor to the current HTMLElement's `display` style\n     * Note: Show/Hide will not change the display to 'flex' but will set it to 'block'\n     * unless it was already explicitly specified inline or in a CSS stylesheet.\n     * @return {?}\n     */\n    ShowHideDirective.prototype._getDisplayStyle = /**\n     * Override accessor to the current HTMLElement's `display` style\n     * Note: Show/Hide will not change the display to 'flex' but will set it to 'block'\n     * unless it was already explicitly specified inline or in a CSS stylesheet.\n     * @return {?}\n     */\n        function () {\n            return this.layout ? 'flex' : _super.prototype._getDisplayStyle.call(this);\n        };\n    /**\n     * On changes to any @Input properties...\n     * Default to use the non-responsive Input value ('fxShow')\n     * Then conditionally override with the mq-activated Input's current value\n     */\n    /**\n     * On changes to any \\@Input properties...\n     * Default to use the non-responsive Input value ('fxShow')\n     * Then conditionally override with the mq-activated Input's current value\n     * @param {?} changes\n     * @return {?}\n     */\n    ShowHideDirective.prototype.ngOnChanges = /**\n     * On changes to any \\@Input properties...\n     * Default to use the non-responsive Input value ('fxShow')\n     * Then conditionally override with the mq-activated Input's current value\n     * @param {?} changes\n     * @return {?}\n     */\n        function (changes) {\n            if (this.hasInitialized && (changes['show'] != null || this._mqActivation)) {\n                this._updateWithValue();\n            }\n        };\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     */\n    /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n    ShowHideDirective.prototype.ngOnInit = /**\n     * After the initial onChanges, build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            _super.prototype.ngOnInit.call(this);\n            var /** @type {?} */ value = this._getDefaultVal('show', true);\n            // Build _mqActivation controller\n            this._listenForMediaQueryChanges('show', value, function (changes) {\n                _this._updateWithValue(changes.value);\n            });\n            this._updateWithValue();\n        };\n    /**\n     * @return {?}\n     */\n    ShowHideDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            _super.prototype.ngOnDestroy.call(this);\n            if (this._layoutWatcher) {\n                this._layoutWatcher.unsubscribe();\n            }\n        };\n    // *********************************************\n    // Protected methods\n    // *********************************************\n    /** Validate the visibility value and then update the host's inline display style */\n    /**\n     * Validate the visibility value and then update the host's inline display style\n     * @param {?=} value\n     * @return {?}\n     */\n    ShowHideDirective.prototype._updateWithValue = /**\n     * Validate the visibility value and then update the host's inline display style\n     * @param {?=} value\n     * @return {?}\n     */\n        function (value) {\n            value = value || this._getDefaultVal('show', true);\n            if (this._mqActivation) {\n                value = this._mqActivation.activatedInput;\n            }\n            var /** @type {?} */ shouldShow = this._validateTruthy(value);\n            this._applyStyleToElement(this._buildCSS(shouldShow));\n            if (isPlatformServer(this.platformId) && this.serverModuleLoaded) {\n                this.nativeElement.style.setProperty('display', '');\n            }\n        };\n    /** Build the CSS that should be assigned to the element instance */\n    /**\n     * Build the CSS that should be assigned to the element instance\n     * @param {?} show\n     * @return {?}\n     */\n    ShowHideDirective.prototype._buildCSS = /**\n     * Build the CSS that should be assigned to the element instance\n     * @param {?} show\n     * @return {?}\n     */\n        function (show) {\n            return { 'display': show ? this._display : 'none' };\n        };\n    /**  Validate the to be not FALSY */\n    /**\n     * Validate the to be not FALSY\n     * @param {?} show\n     * @return {?}\n     */\n    ShowHideDirective.prototype._validateTruthy = /**\n     * Validate the to be not FALSY\n     * @param {?} show\n     * @return {?}\n     */\n        function (show) {\n            return (FALSY.indexOf(show) == -1);\n        };\n    return ShowHideDirective;\n}(BaseDirective));\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Extends an object with the *enumerable* and *own* properties of one or more source objects,\n * similar to Object.assign.\n *\n * @param {?} dest The object which will have properties copied to it.\n * @param {...?} sources The source objects from which properties will be copied.\n * @return {?}\n */\nfunction extendObject(dest) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    if (dest == null) {\n        throw TypeError('Cannot convert undefined or null to object');\n    }\n    for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {\n        var source = sources_1[_a];\n        if (source != null) {\n            for (var /** @type {?} */ key in source) {\n                if (source.hasOwnProperty(key)) {\n                    dest[key] = source[key];\n                }\n            }\n        }\n    }\n    return dest;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * NgStyle allowed inputs\n */\nvar /**\n * NgStyle allowed inputs\n */ NgStyleKeyValue = /** @class */ /*@__PURE__*/ (function () {\n    function NgStyleKeyValue(key, value, noQuotes) {\n        if (noQuotes === void 0) {\n            noQuotes = true;\n        }\n        this.key = key;\n        this.value = value;\n        this.key = noQuotes ? key.replace(/['\"]/g, '').trim() : key.trim();\n        this.value = noQuotes ? value.replace(/['\"]/g, '').trim() : value.trim();\n        this.value = this.value.replace(/;/, '');\n    }\n    return NgStyleKeyValue;\n}());\n/**\n * Transform Operators for \\@angular/flex-layout NgStyle Directive\n */\nvar /** @type {?} */ ngStyleUtils = {\n    getType: getType,\n    buildRawList: buildRawList,\n    buildMapFromList: buildMapFromList,\n    buildMapFromSet: buildMapFromSet\n};\n/**\n * @param {?} target\n * @return {?}\n */\nfunction getType(target) {\n    var /** @type {?} */ what = typeof target;\n    if (what === 'object') {\n        return (target.constructor === Array) ? 'array' :\n            (target.constructor === Set) ? 'set' : 'object';\n    }\n    return what;\n}\n/**\n * Split string of key:value pairs into Array of k-v pairs\n * e.g.  'key:value; key:value; key:value;' -> ['key:value',...]\n * @param {?} source\n * @param {?=} delimiter\n * @return {?}\n */\nfunction buildRawList(source, delimiter) {\n    if (delimiter === void 0) {\n        delimiter = ';';\n    }\n    return String(source)\n        .trim()\n        .split(delimiter)\n        .map(function (val) { return val.trim(); })\n        .filter(function (val) { return val !== ''; });\n}\n/**\n * Convert array of key:value strings to a iterable map object\n * @param {?} styles\n * @param {?=} sanitize\n * @return {?}\n */\nfunction buildMapFromList(styles, sanitize) {\n    var /** @type {?} */ sanitizeValue = function (it) {\n        if (sanitize) {\n            it.value = sanitize(it.value);\n        }\n        return it;\n    };\n    return styles\n        .map(stringToKeyValue)\n        .filter(function (entry) { return !!entry; })\n        .map(sanitizeValue)\n        .reduce(keyValuesToMap, {});\n}\n/**\n * Convert Set<string> or raw Object to an iterable NgStyleMap\n * @param {?} source\n * @param {?=} sanitize\n * @return {?}\n */\nfunction buildMapFromSet(source, sanitize) {\n    var /** @type {?} */ list = new Array();\n    if (getType(source) == 'set') {\n        source.forEach(function (entry) { return list.push(entry); });\n    }\n    else {\n        // simple hashmap\n        Object.keys(source).forEach(function (key) {\n            list.push(key + \":\" + source[key]);\n        });\n    }\n    return buildMapFromList(list, sanitize);\n}\n/**\n * Convert 'key:value' -> [key, value]\n * @param {?} it\n * @return {?}\n */\nfunction stringToKeyValue(it) {\n    var _a = it.split(':'), key = _a[0], val = _a[1];\n    return val ? new NgStyleKeyValue(key, val) : null;\n}\n/**\n * Convert [ [key,value] ] -> { key : value }\n * @param {?} map\n * @param {?} entry\n * @return {?}\n */\nfunction keyValuesToMap(map, entry) {\n    if (!!entry.key) {\n        map[entry.key] = entry.value;\n    }\n    return map;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Directive to add responsive support for ngStyle.\n *\n */\nvar StyleDirective = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(StyleDirective, _super);\n    /* tslint:enable */\n    /**\n     *  Constructor for the ngStyle subclass; which adds selectors and\n     *  a MediaQuery Activation Adapter\n     */\n    function StyleDirective(monitor, _sanitizer, _ngEl, _renderer, _differs, _ngStyleInstance, _styler) {\n        var _this = _super.call(this, monitor, _ngEl, _styler) || this;\n        _this.monitor = monitor;\n        _this._sanitizer = _sanitizer;\n        _this._ngEl = _ngEl;\n        _this._renderer = _renderer;\n        _this._differs = _differs;\n        _this._ngStyleInstance = _ngStyleInstance;\n        _this._styler = _styler;\n        _this._configureAdapters();\n        return _this;\n    }\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleBase\", {\n        set: /**\n         * Intercept ngStyle assignments so we cache the default styles\n         * which are merged with activated styles or used as fallbacks.\n         * @param {?} val\n         * @return {?}\n         */ function (val) {\n            var /** @type {?} */ key = 'ngStyle';\n            this._base.cacheInput(key, val, true); // convert val to hashmap\n            this._ngStyleInstance.ngStyle = this._base.queryInput(key);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleXs\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngStyleXs', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleSm\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngStyleSm', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleMd\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngStyleMd', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleLg\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngStyleLg', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleXl\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngStyleXl', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleLtSm\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngStyleLtSm', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleLtMd\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngStyleLtMd', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleLtLg\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngStyleLtLg', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleLtXl\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngStyleLtXl', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleGtXs\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngStyleGtXs', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleGtSm\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngStyleGtSm', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleGtMd\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngStyleGtMd', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StyleDirective.prototype, \"ngStyleGtLg\", {\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */ function (val) { this._base.cacheInput('ngStyleGtLg', val, true); },\n        enumerable: true,\n        configurable: true\n    });\n    // ******************************************************************\n    // Lifecycle Hooks\n    // ******************************************************************\n    /**\n     * For @Input changes on the current mq activation property\n     */\n    /**\n     * For \\@Input changes on the current mq activation property\n     * @param {?} changes\n     * @return {?}\n     */\n    StyleDirective.prototype.ngOnChanges = /**\n     * For \\@Input changes on the current mq activation property\n     * @param {?} changes\n     * @return {?}\n     */\n        function (changes) {\n            if (this._base.activeKey in changes) {\n                this._ngStyleInstance.ngStyle = this._base.mqActivation.activatedInput || '';\n            }\n        };\n    /**\n     * @return {?}\n     */\n    StyleDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            this._configureMQListener();\n        };\n    /**\n     * For ChangeDetectionStrategy.onPush and ngOnChanges() updates\n     */\n    /**\n     * For ChangeDetectionStrategy.onPush and ngOnChanges() updates\n     * @return {?}\n     */\n    StyleDirective.prototype.ngDoCheck = /**\n     * For ChangeDetectionStrategy.onPush and ngOnChanges() updates\n     * @return {?}\n     */\n        function () {\n            this._ngStyleInstance.ngDoCheck();\n        };\n    /**\n     * @return {?}\n     */\n    StyleDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._base.ngOnDestroy();\n            delete this._ngStyleInstance;\n        };\n    // ******************************************************************\n    // Internal Methods\n    // ******************************************************************\n    /**\n       * Configure adapters (that delegate to an internal ngClass instance) if responsive\n       * keys have been defined.\n       */\n    /**\n     * Configure adapters (that delegate to an internal ngClass instance) if responsive\n     * keys have been defined.\n     * @return {?}\n     */\n    StyleDirective.prototype._configureAdapters = /**\n     * Configure adapters (that delegate to an internal ngClass instance) if responsive\n     * keys have been defined.\n     * @return {?}\n     */\n        function () {\n            this._base = new BaseDirectiveAdapter('ngStyle', this.monitor, this._ngEl, this._styler);\n            if (!this._ngStyleInstance) {\n                // Create an instance NgClass Directive instance only if `ngClass=\"\"` has NOT been\n                // defined on the same host element; since the responsive variations may be defined...\n                this._ngStyleInstance = new NgStyle(this._differs, this._ngEl, this._renderer);\n            }\n            this._buildCacheInterceptor();\n            this._fallbackToStyle();\n        };\n    /**\n     * Build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     */\n    /**\n     * Build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @param {?=} baseKey\n     * @return {?}\n     */\n    StyleDirective.prototype._configureMQListener = /**\n     * Build an mqActivation object that bridges\n     * mql change events to onMediaQueryChange handlers\n     * @param {?=} baseKey\n     * @return {?}\n     */\n        function (baseKey) {\n            var _this = this;\n            if (baseKey === void 0) {\n                baseKey = 'ngStyle';\n            }\n            var /** @type {?} */ fallbackValue = this._base.queryInput(baseKey);\n            this._base.listenForMediaQueryChanges(baseKey, fallbackValue, function (changes) {\n                _this._ngStyleInstance.ngStyle = changes.value || '';\n                _this._ngStyleInstance.ngDoCheck();\n            });\n        };\n    // ************************************************************************\n    // Private Internal Methods\n    // ************************************************************************\n    /**\n     * Build intercept to convert raw strings to ngStyleMap\n     */\n    /**\n     * Build intercept to convert raw strings to ngStyleMap\n     * @return {?}\n     */\n    StyleDirective.prototype._buildCacheInterceptor = /**\n     * Build intercept to convert raw strings to ngStyleMap\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            var /** @type {?} */ cacheInput = this._base.cacheInput.bind(this._base);\n            this._base.cacheInput = function (key, source, cacheRaw, merge) {\n                if (cacheRaw === void 0) {\n                    cacheRaw = false;\n                }\n                if (merge === void 0) {\n                    merge = true;\n                }\n                var /** @type {?} */ styles = _this._buildStyleMap(source);\n                if (merge) {\n                    styles = extendObject({}, _this._base.inputMap['ngStyle'], styles);\n                }\n                cacheInput(key, styles, cacheRaw);\n            };\n        };\n    /**\n     * Convert raw strings to ngStyleMap; which is required by ngStyle\n     * NOTE: Raw string key-value pairs MUST be delimited by `;`\n     *       Comma-delimiters are not supported due to complexities of\n     *       possible style values such as `rgba(x,x,x,x)` and others\n     */\n    /**\n     * Convert raw strings to ngStyleMap; which is required by ngStyle\n     * NOTE: Raw string key-value pairs MUST be delimited by `;`\n     *       Comma-delimiters are not supported due to complexities of\n     *       possible style values such as `rgba(x,x,x,x)` and others\n     * @param {?} styles\n     * @return {?}\n     */\n    StyleDirective.prototype._buildStyleMap = /**\n     * Convert raw strings to ngStyleMap; which is required by ngStyle\n     * NOTE: Raw string key-value pairs MUST be delimited by `;`\n     *       Comma-delimiters are not supported due to complexities of\n     *       possible style values such as `rgba(x,x,x,x)` and others\n     * @param {?} styles\n     * @return {?}\n     */\n        function (styles) {\n            var _this = this;\n            var /** @type {?} */ sanitizer = function (val) {\n                // Always safe-guard (aka sanitize) style property values\n                return _this._sanitizer.sanitize(SecurityContext.STYLE, val) || '';\n            };\n            if (styles) {\n                switch (ngStyleUtils.getType(styles)) {\n                    case 'string': return ngStyleUtils.buildMapFromList(ngStyleUtils.buildRawList(styles), sanitizer);\n                    case 'array': return ngStyleUtils.buildMapFromList(/** @type {?} */ (styles), sanitizer);\n                    case 'set': return ngStyleUtils.buildMapFromSet(styles, sanitizer);\n                    default: return ngStyleUtils.buildMapFromSet(styles, sanitizer);\n                }\n            }\n            return styles;\n        };\n    /**\n     * Initial lookup of raw 'class' value (if any)\n     */\n    /**\n     * Initial lookup of raw 'class' value (if any)\n     * @return {?}\n     */\n    StyleDirective.prototype._fallbackToStyle = /**\n     * Initial lookup of raw 'class' value (if any)\n     * @return {?}\n     */\n        function () {\n            if (!this._base.queryInput('ngStyle')) {\n                this.ngStyleBase = this._getAttributeValue('style') || '';\n            }\n        };\n    return StyleDirective;\n}(BaseDirective));\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ ALL_DIRECTIVES = [\n    ShowHideDirective,\n    ClassDirective,\n    StyleDirective,\n    ImgSrcDirective\n];\n/**\n * *****************************************************************\n * Define module for the Extended API\n * *****************************************************************\n */\nvar ExtendedModule = /** @class */ /*@__PURE__*/ (function () {\n    function ExtendedModule() {\n    }\n    return ExtendedModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nexport { ExtendedModule, ClassDirective, ImgSrcDirective, negativeOf, ShowHideDirective, StyleDirective };\n//# sourceMappingURL=extended.es5.js.map\n",null]}